name: Update Playwright snapshots

on:
  workflow_dispatch: {}

jobs:
  update-snapshots:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'pnpm'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build API & web
        run: |
          pnpm --filter ./apps/api run build || true
          pnpm --filter ./apps/web run build || true

      - name: Prepare database & seed (api)
        working-directory: ./apps/api
        run: |
          npx prisma db push --accept-data-loss || true
          pnpm run seed || true

      - name: Start API + web (background)
        run: |
          pnpm --filter ./apps/api run start &> api.log &
          pnpm --filter ./apps/web run start &> web.log &
          # wait for servers
          for i in {1..30}; do if curl -sSf http://localhost:3001/ >/dev/null 2>&1; then break; fi; sleep 1; done || true
          for i in {1..30}; do if curl -sSf http://localhost:3000/ >/dev/null 2>&1; then break; fi; sleep 1; done || true

      - name: Install Playwright browsers
        working-directory: ./apps/web
        run: pnpm run e2e:install

      - name: Update Playwright snapshots
        working-directory: ./apps/web
        id: update
        run: |
          set -e
          pnpm run test:e2e:update || true

      - name: Check for snapshot changes
        run: |
          set -e
          git status --porcelain
        continue-on-error: true

      - name: Commit and push updated snapshots
        id: commit
        if: ${{ steps.update.outcome == 'success' || always() }}
        run: |
          set -e
          # Only commit when there are changes in the tests snapshot dir
          git config user.name 'github-actions[bot]'
          git config user.email 'github-actions[bot]@users.noreply.github.com'
          SNAP_CHANGES=$(git status --porcelain | grep -E "tests/.+\.spec\.ts-snapshots|tests/.+-snapshots" || true)
          if [ -n "$SNAP_CHANGES" ]; then
            BRANCH="update/snapshots-$(date +%s)"
            git checkout -b "$BRANCH"
            git add -A
            git commit -m "chore(e2e): update Playwright snapshots [skip ci]"
            git push origin "$BRANCH"
            echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          else
            echo "no changes" >> $GITHUB_OUTPUT
          fi

      - name: Create PR for snapshot changes
        if: steps.commit.outputs.branch != ''
        uses: actions/github-script@v7
        env:
          BRANCH: ${{ steps.commit.outputs.branch }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const branch = process.env.BRANCH || '';
            if (!branch) {
              console.log('No snapshot branch created — nothing to PR');
            } else {
              const pr = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: branch,
                base: context.repo.default_branch,
                title: 'chore: update Playwright snapshots (CI)',
                body: 'Automated snapshot update generated by CI. Please review snapshots and merge if approved.'
              });
              console.log('Created PR:', pr.data.html_url);
            }
      - name: Auto-approve and merge snapshot PR (trusted flow)
        if: steps.commit.outputs.branch != ''
        uses: actions/github-script@v7
        env:
          BRANCH: ${{ steps.commit.outputs.branch }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
              const branch = process.env.BRANCH || '';
              if (!branch) {
                console.log('No snapshot branch available, skipping auto-merge');
                return;
              }

              // find PR created for this branch
              const prs = await github.rest.pulls.list({ owner: context.repo.owner, repo: context.repo.repo, head: `${context.repo.owner}:${branch}` });
              if (!prs.data || prs.data.length === 0) {
                console.log('No PR found for branch', branch);
                return;
              }

              const pr = prs.data[0];
              console.log('Found PR', pr.number, 'by', pr.user?.login, 'draft:', pr.draft);

              // Repository-level snapshot policy (falls back to defaults)
              let trustedPrefix = 'update/snapshots-';
              let trustedAuthors = ['github-actions[bot]', 'github-actions'];
              try {
                const repoContent = await github.rest.repos.getContent({ owner: context.repo.owner, repo: context.repo.repo, path: '.github/snapshot-policy.json' });
                if (repoContent && repoContent.data && repoContent.data.content) {
                  const json = Buffer.from(repoContent.data.content, 'base64').toString();
                  const cfg = JSON.parse(json || '{}');
                  if (Array.isArray(cfg.trustedPrefixes) && cfg.trustedPrefixes.length > 0) trustedPrefix = cfg.trustedPrefixes[0] || trustedPrefix;
                  if (Array.isArray(cfg.trustedAuthors) && cfg.trustedAuthors.length > 0) trustedAuthors = cfg.trustedAuthors;
                }
              } catch (err) {
                console.log('No repo-level policy found or failed to parse, using defaults', String(err));
              }
              if (!branch.startsWith(trustedPrefix)) {
                console.log('Branch does not match trusted prefix, skipping auto-merge');
                return;
              }
              if (!trustedAuthors.includes(pr.user?.login)) {
                console.log('PR author is not trusted:', pr.user?.login, 'skipping auto-merge');
                return;
              }
              if (pr.draft) {
                console.log('PR is a draft; skipping auto-merge');
                return;
              }

              // approve the PR
              console.log('Approving PR', pr.number);
              await github.rest.pulls.createReview({ owner: context.repo.owner, repo: context.repo.repo, pull_number: pr.number, event: 'APPROVE', body: 'Auto-approved by CI snapshot workflow' });

              // attempt to merge with a 'squash' merge if possible
              try {
                console.log('Merging PR', pr.number);
                const mergeRes = await github.rest.pulls.merge({ owner: context.repo.owner, repo: context.repo.repo, pull_number: pr.number, merge_method: 'squash' });
                  if (mergeRes && (mergeRes.data?.merged || mergeRes.status === 200)) {
                  console.log('PR merged successfully');
                  // determine merge SHA and run URL for audit
                  const mergeSha = mergeRes?.data?.merge_commit_sha || mergeRes?.data?.sha || null;
                  const shortSha = mergeSha ? mergeSha.substring(0, 7) : 'unknown';
                  const server = process.env.GITHUB_SERVER_URL || 'https://github.com';
                  const repo = process.env.GITHUB_REPOSITORY || `${context.repo.owner}/${context.repo.repo}`;
                  const commitUrl = mergeSha ? `${server}/${repo}/commit/${mergeSha}` : 'unknown';
                  const runUrl = process.env.GITHUB_RUN_ID ? `${server}/${repo}/actions/runs/${process.env.GITHUB_RUN_ID}` : 'unknown';
                  // Post an audit comment on the PR so there's an explicit trail for the auto-merge
                  const commentBody = `This PR was automatically approved and merged by the snapshot CI workflow (policy: .github/snapshot-policy.json).\n\nMerge commit: ${mergeSha ? `[${shortSha}](${commitUrl})` : 'unknown'}\nWorkflow run: ${runUrl}\n\nIf this change is unexpected, you can revert the merge or open an issue.`;
                  await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, body: commentBody });

                  // Build a metadata JSON file and write it to the workspace for upload
                  try {
                    const filesRes = await github.rest.pulls.listFiles({ owner: context.repo.owner, repo: context.repo.repo, pull_number: pr.number });
                    const files = filesRes.data ? filesRes.data.map(f => f.filename) : [];
                    const mergedBy = mergeRes?.data?.merged_by?.login || pr.user?.login || 'unknown';
                    const metadata = {
                      pr: pr.number,
                      merge_sha: mergeSha || null,
                      short_sha: shortSha || null,
                      commit_url: commitUrl || null,
                      run_url: runUrl || null,
                      merged_by: mergedBy,
                      files_changed: files,
                      timestamp: new Date().toISOString()
                    };
                    const fs = require('fs');
                    const dir = 'snapshot-merge-artifacts';
                    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
                    const filePath = `${dir}/snapshot-merge-${pr.number}-${Date.now()}.json`;
                    fs.writeFileSync(filePath, JSON.stringify(metadata, null, 2));
                    console.log('Wrote merge metadata to', filePath);
                  } catch (e) {
                    console.log('Failed to write merge metadata file', String(e));
                  }
                } else {
                  console.log('Merge did not report as merged; response:', JSON.stringify(mergeRes?.data || mergeRes));
                }
              } catch (err) {
                console.log('Merge failed, trying regular merge', String(err));
              }

      - name: Upload merge metadata artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: snapshot-merge-artifacts
          path: snapshot-merge-artifacts

      - name: Publish snapshot preview images (GH Pages + S3)
        if: ${{ always() }}
        env:
          UPLOAD_PREVIEW_TO_PAGES: ${{ secrets.UPLOAD_PREVIEW_TO_PAGES || 'false' }}
          GH_PAGES_BRANCH: ${{ secrets.GH_PAGES_BRANCH || 'snapshot-previews' }}
          UPLOAD_PREVIEW_TO_S3: ${{ secrets.UPLOAD_PREVIEW_TO_S3 || 'false' }}
          S3_PREVIEW_BUCKET: ${{ secrets.S3_PREVIEW_BUCKET || '' }}
          S3_UPLOAD_PREFIX: ${{ secrets.S3_UPLOAD_PREFIX || 'snapshot-previews' }}
          AWS_REGION: ${{ secrets.AWS_REGION || '' }}
          PREVIEWS_MAX: ${{ secrets.PREVIEWS_MAX || '5' }}
          # thumbnail sizes (width px)
          THUMB_SMALL_W: ${{ secrets.THUMB_SMALL_W || '320' }}
          THUMB_MED_W: ${{ secrets.THUMB_MED_W || '1280' }}
          PREVIEWS_KEEP: ${{ secrets.PREVIEWS_KEEP || '10' }}
          GH_PAGES_CLEANUP: ${{ secrets.GH_PAGES_CLEANUP || 'true' }}
          S3_KEEP: ${{ secrets.S3_KEEP || '' }}
          S3_RETENTION_DAYS: ${{ secrets.S3_RETENTION_DAYS || '30' }}
        run: |
          set -euo pipefail
          # Find up to PREVIEWS_MAX recent image files in the workspace (png/jpg/webp/jpeg)
          mapfile -t ALL_FILES < <(find . -type f \( -iname '*.png' -o -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.webp' \) -print0 | xargs -0 ls -1 -t || true)
          if [ ${#ALL_FILES[@]} -eq 0 ]; then echo "No image files found to publish."; exit 0; fi
          MAX=${PREVIEWS_MAX:-5}

          PR_FILE=$(ls snapshot-merge-artifacts/snapshot-merge-*.json 2>/dev/null | tail -n1 || true)
          if [ -z "$PR_FILE" ]; then PR_NUM="snapshot-$(date +%s)"; else PR_NUM=$(basename "$PR_FILE" | sed -E 's/^snapshot-merge-([0-9]+)-.*$/\1/'); fi
          TIMESTAMP=$(date +%s)

          PREVIEW_URLS=()

          COUNT=0
          for SRC in "${ALL_FILES[@]}"; do
            if [ $COUNT -ge $MAX ]; then break; fi
            BASENAME=$(basename "$SRC")
            DEST_NAME="preview-${PR_NUM}-${TIMESTAMP}-${COUNT}-${BASENAME}"
            # thumbnail names
            THUMB_SMALL_NAME="thumb-small-${PR_NUM}-${TIMESTAMP}-${COUNT}-${BASENAME}"
            THUMB_MED_NAME="thumb-med-${PR_NUM}-${TIMESTAMP}-${COUNT}-${BASENAME}"

            # create thumbnails (ImageMagick convert)
            if ! command -v convert >/dev/null 2>&1; then
              echo "ImageMagick not found, installing"
              sudo apt-get update -y || true
              sudo apt-get install -y imagemagick || true
            fi
            echo "Creating thumbnails: $THUMB_SMALL_NAME, $THUMB_MED_NAME"
            convert "$SRC" -resize ${THUMB_SMALL_W}x "$THUMB_SMALL_NAME" || cp "$SRC" "$THUMB_SMALL_NAME" || true
            convert "$SRC" -resize ${THUMB_MED_W}x "$THUMB_MED_NAME" || cp "$SRC" "$THUMB_MED_NAME" || true

              if [ "${UPLOAD_PREVIEW_TO_PAGES}" = 'true' ]; then
              echo "Publishing $SRC to GitHub Pages branch: ${GH_PAGES_BRANCH} as previews/${DEST_NAME}"
              git config user.name 'github-actions[bot]'
              git config user.email 'github-actions[bot]@users.noreply.github.com'
              git fetch origin ${GH_PAGES_BRANCH} || true
              git checkout --orphan ${GH_PAGES_BRANCH} || git checkout -B ${GH_PAGES_BRANCH}
              mkdir -p previews
              cp "$SRC" "previews/${DEST_NAME}"
              git add -A previews/${DEST_NAME}
              git commit -m "chore(previews): add snapshot preview ${DEST_NAME} [skip ci]" || true
              git push origin ${GH_PAGES_BRANCH} --force || true
              OWNER=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1)
              REPO=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)
              PAGE_URL="https://${OWNER}.github.io/${REPO}/previews/${DEST_NAME}"
              PREVIEW_URLS+=("${PAGE_URL}")
              # also publish thumbnails to GH Pages
              cp "$THUMB_SMALL_NAME" "previews/${THUMB_SMALL_NAME}"
              git add -A previews/${THUMB_SMALL_NAME}
              cp "$THUMB_MED_NAME" "previews/${THUMB_MED_NAME}"
              git add -A previews/${THUMB_MED_NAME}
              PAGE_THUMB_SMALL_URL="https://${OWNER}.github.io/${REPO}/previews/${THUMB_SMALL_NAME}"
              PAGE_THUMB_MED_URL="https://${OWNER}.github.io/${REPO}/previews/${THUMB_MED_NAME}"
              PREVIEW_URLS+=("${PAGE_THUMB_SMALL_URL}")
              PREVIEW_URLS+=("${PAGE_THUMB_MED_URL}")
            fi

            if [ "${UPLOAD_PREVIEW_TO_S3}" = 'true' ] && [ -n "${S3_PREVIEW_BUCKET}" ]; then
              echo "Uploading $SRC to S3 bucket: ${S3_PREVIEW_BUCKET}/${S3_UPLOAD_PREFIX}/${DEST_NAME}"
              if ! command -v aws >/dev/null 2>&1; then
                pip install --user awscli || true
                export PATH="$HOME/.local/bin:$PATH"
              fi
              KEY_PATH="${S3_UPLOAD_PREFIX}/${DEST_NAME}"
              aws s3 cp "$SRC" "s3://${S3_PREVIEW_BUCKET}/${KEY_PATH}" --acl public-read || echo "S3 upload failed for $SRC"
              if [ -n "${AWS_REGION}" ]; then
                S3_URL="https://${S3_PREVIEW_BUCKET}.s3.${AWS_REGION}.amazonaws.com/${KEY_PATH}"
              else
                S3_URL="https://${S3_PREVIEW_BUCKET}.s3.amazonaws.com/${KEY_PATH}"
              fi
              PREVIEW_URLS+=("${S3_URL}")
              # upload thumbnails to S3 as well
              if [ -n "$DISABLE_S3_THUMBS" ] || true; then
                : # intentionally a no-op placeholder — allow optional disabling in future
              fi
              if [ -n "${DISCORD_IMAGE_URL}" ] ; then :; fi || true
              KEY_PATH_SMALL="${S3_UPLOAD_PREFIX}/${THUMB_SMALL_NAME}"
              KEY_PATH_MED="${S3_UPLOAD_PREFIX}/${THUMB_MED_NAME}"
              aws s3 cp "$THUMB_SMALL_NAME" "s3://${S3_PREVIEW_BUCKET}/${KEY_PATH_SMALL}" --acl public-read || echo "S3 upload failed for $THUMB_SMALL_NAME"
              aws s3 cp "$THUMB_MED_NAME" "s3://${S3_PREVIEW_BUCKET}/${KEY_PATH_MED}" --acl public-read || echo "S3 upload failed for $THUMB_MED_NAME"
              if [ -n "${AWS_REGION}" ]; then
                S3_URL_SMALL="https://${S3_PREVIEW_BUCKET}.s3.${AWS_REGION}.amazonaws.com/${KEY_PATH_SMALL}"
                S3_URL_MED="https://${S3_PREVIEW_BUCKET}.s3.${AWS_REGION}.amazonaws.com/${KEY_PATH_MED}"
              else
                S3_URL_SMALL="https://${S3_PREVIEW_BUCKET}.s3.amazonaws.com/${KEY_PATH_SMALL}"
                S3_URL_MED="https://${S3_PREVIEW_BUCKET}.s3.amazonaws.com/${KEY_PATH_MED}"
              fi
              PREVIEW_URLS+=("${S3_URL_SMALL}")
              PREVIEW_URLS+=("${S3_URL_MED}")
            fi

            COUNT=$((COUNT+1))
          done

          # Write preview url(s) back into latest metadata file if present
          META=$(ls snapshot-merge-artifacts/snapshot-merge-*.json 2>/dev/null | tail -n1 || true)
          if [ -n "$META" ]; then
            echo "Adding preview_urls to metadata file: $META"
            for u in "${PREVIEW_URLS[@]}"; do
              tmp=$(mktemp)
              jq --arg url "$u" 'if .preview_urls then .preview_urls += [$url] else .preview_urls = [$url] end' "$META" > "$tmp" && mv "$tmp" "$META"
            done
            # Also write thumbnail_urls as a sibling field if there are generated thumb urls
            # thumbnail urls are contained in every 2nd item added (small then med) in PREVIEW_URLS after main image
            # We'll extract any small/med urls that contain thumb-small or thumb-med
            tmp2=$(mktemp)
            jq '.["thumbnail_urls"] = ([] )' "$META" > "$tmp2" && mv "$tmp2" "$META" || true
            for u in "${PREVIEW_URLS[@]}"; do
              case "$u" in
                *thumb-small-*) tmp=$(mktemp); jq --arg url "$u" '.thumbnail_urls += [$url]' "$META" > "$tmp" && mv "$tmp" "$META" || true ;;
                *thumb-med-*) tmp=$(mktemp); jq --arg url "$u" '.thumbnail_urls += [$url]' "$META" > "$tmp" && mv "$tmp" "$META" || true ;;
                *) : ;;
              esac
            done
            echo "Updated metadata:" && cat "$META"
          else
            echo "No metadata file to update"
          fi

          # Optional cleanup/retention for GH Pages
          if [ "${UPLOAD_PREVIEW_TO_PAGES}" = 'true' ] && [ "${GH_PAGES_CLEANUP}" = 'true' ]; then
            echo "Running GH Pages cleanup (keep ${PREVIEWS_KEEP})"
            # ensure we have the branch checked out and up to date
            git checkout ${GH_PAGES_BRANCH} || git checkout -B ${GH_PAGES_BRANCH}
            git pull origin ${GH_PAGES_BRANCH} || true
            # list preview files in previews/ sorted by mtime (oldest last), keep newest PREVIEWS_KEEP
            files=( $(ls -1t previews | tail -n +$((PREVIEWS_KEEP+1)) 2>/dev/null || true) )
            if [ ${#files[@]} -gt 0 ]; then
              for f in "${files[@]}"; do
                echo "Removing old preview: previews/$f"
                git rm -f "previews/$f" || rm -f "previews/$f" || true
              done
              git commit -m "chore(previews): remove old previews (keep ${PREVIEWS_KEEP}) [skip ci]" || true
              git push origin ${GH_PAGES_BRANCH} || true
            else
              echo "No old previews to remove on GH Pages"
            fi
          fi

          # Optional cleanup for S3 (by retention days or keep-last N)
          if [ "${UPLOAD_PREVIEW_TO_S3}" = 'true' ] && [ -n "${S3_PREVIEW_BUCKET}" ]; then
            echo "S3 cleanup: looking for objects in ${S3_PREVIEW_BUCKET}/${S3_UPLOAD_PREFIX}"
            # by retention days
            if [ -n "${S3_RETENTION_DAYS}" ] && [ "${S3_RETENTION_DAYS}" != "" ]; then
              echo "Deleting S3 objects older than ${S3_RETENTION_DAYS} days"
              # get date threshold
              cutoff=$(date -d "-${S3_RETENTION_DAYS} days" +%s)
              # list objects with their LastModified and delete older ones
              aws s3api list-objects-v2 --bucket "${S3_PREVIEW_BUCKET}" --prefix "${S3_UPLOAD_PREFIX}/" --query 'Contents[].{Key: Key,LastModified: LastModified}' --output text | while read -r key last; do
                # LastModified is like 2025-12-08T...Z; convert to seconds
                ts=$(date -d "$last" +%s || echo 0)
                if [ "$ts" -ne 0 ] && [ "$ts" -lt "$cutoff" ]; then
                  echo "Deleting old S3 object: $key"
                  aws s3 rm "s3://${S3_PREVIEW_BUCKET}/$key" || echo "failed to delete $key"
                fi
              done || true
            fi

            # keep-last N if configured
            if [ -n "${S3_KEEP}" ] && [ "${S3_KEEP}" != "" ]; then
              echo "Keeping last ${S3_KEEP} S3 objects and deleting the rest"
              # list objects sorted by LastModified desc and keep first S3_KEEP
              keys=( $(aws s3api list-objects-v2 --bucket "${S3_PREVIEW_BUCKET}" --prefix "${S3_UPLOAD_PREFIX}/" --query 'reverse(sort_by(Contents,&LastModified))[*].Key' --output text) ) || true
              if [ ${#keys[@]} -gt ${S3_KEEP} ]; then
                for ((i=S3_KEEP;i<${#keys[@]};i++)); do
                  k=${keys[$i]}
                  echo "Removing S3 object: $k"
                  aws s3 rm "s3://${S3_PREVIEW_BUCKET}/$k" || echo "failed to delete $k"
                done
              else
                echo "No S3 objects to remove (total ${#keys[@]})"
              fi
            fi
          fi

      - name: Notification payload dump (test only)
        if: ${{ secrets.TEST_NOTIFY == 'true' }}
        run: |
          set -e
          FILE=$(ls snapshot-merge-artifacts/*.json | head -n1 || true)
          if [ -z "$FILE" ]; then echo "No metadata file found. Skipping dump." ; exit 0; fi
          echo '--- metadata content ---'
          cat "$FILE"
          echo '--- preview_urls ---'
          jq -r '.preview_urls // [] | .[]' "$FILE" || true
          echo '--- thumbnail_urls ---'
          jq -r '.thumbnail_urls // [] | .[]' "$FILE" || true
          echo '--- slack sample header ---'
          jq -r '. | "PR: \(.pr)  short_sha: \(.short_sha)  merged_by: \(.merged_by)  run_url: \(.run_url)"' "$FILE" || true

          # SAMPLE: build the Slack payload same as the live step (for verification)
          echo '--- sample slack payload ---'
          SLACK_MENTION=${{ secrets.SLACK_MENTION || '' }}
          SLACK_EMOJI=${{ secrets.SLACK_EMOJI || '' }}
          SLACK_COLOR=${{ secrets.SLACK_COLOR || '#36a64f' }}
          SLACK_TITLE_LINK=${{ secrets.SLACK_TITLE_LINK || '' }}
          PR=$(jq -r .pr "$FILE")
          SHORT_SHA=$(jq -r .short_sha "$FILE")
          MERGED_BY=$(jq -r .merged_by "$FILE")
          COMMIT_URL=$(jq -r .commit_url "$FILE")
          RUN_URL=$(jq -r .run_url "$FILE")
          TIMESTAMP=$(jq -r .timestamp "$FILE")
          FILES=$(jq -r '.files_changed | join(", ")' "$FILE")

          HEADER="${SLACK_MENTION} ${SLACK_EMOJI} Playwright snapshots auto-merged (PR #${PR})"
          TITLE_LINK=${SLACK_TITLE_LINK:-}
          jq -n --arg header "$HEADER" --arg pr "$PR" --arg prLink "$TITLE_LINK" --arg shortSha "$SHORT_SHA" --arg mergedBy "$MERGED_BY" --arg commitUrl "$COMMIT_URL" --arg runUrl "$RUN_URL" --arg timestamp "$TIMESTAMP" --arg files "$FILES" --arg color "$SLACK_COLOR" '{text: $header, blocks: [ { type: "section", text: { type: "mrkdwn", text: ("*Playwright snapshots auto-merged*\n*PR:* " + ($prLink | select(.!= "")) + " | `#" + $pr + "` | *Merged by:* " + $mergedBy) } }, { type: "section", fields: [ { type: "mrkdwn", text: ("*Commit*\n<" + $commitUrl + ">") }, { type: "mrkdwn", text: ("*Workflow run*\n<" + $runUrl + ">") } ] }, { type: "context", elements: [ { type: "mrkdwn", text: ("*Files changed:* " + ($files | select(.!= ""))) } ] } ], attachments: [{ color: $color }] }'

          # SAMPLE: Slack thread payload example (initial + thread reply) — include the first preview image (if any)
          echo '--- sample slack thread payload ---'
          SLACK_PREVIEW_IMAGE_URL=${{ secrets.SLACK_PREVIEW_IMAGE_URL || '' }}
          SLACK_PREVIEW_LINK=${{ secrets.SLACK_PREVIEW_LINK || '' }}
          jq -n --arg channel "${{ secrets.SLACK_CHANNEL || 'CHANNEL_ID' }}" --arg text "$HEADER" --argjson blocks "$(echo "$PAYLOAD" | jq -c '.blocks')" '{channel: $channel, text: $text, blocks: $blocks}'
          # simulated threaded reply; thread_ts would be captured from the initial response (e.g. "1234567890.123456")
          # also prefer preview_urls from metadata when TEST_NOTIFY is set
          META_PREVIEWS=$(jq -r '.preview_urls // [] | .[]' "$FILE" | head -n${{ secrets.PREVIEWS_MAX || '5' }} || true)
          FIRST_PREVIEW=$(echo "$META_PREVIEWS" | head -n1 || true)
          # thumbnail preference: prefer small thumb as image, med thumb as link
          FIRST_THUMB=$(jq -r '.thumbnail_urls[0] // empty' "$FILE" || true)
          SECOND_THUMB=$(jq -r '.thumbnail_urls[1] // empty' "$FILE" || true)
          SLACK_PREVIEW_IMAGE_URL=${SLACK_PREVIEW_IMAGE_URL:-$FIRST_THUMB:-$FIRST_PREVIEW}
          SLACK_PREVIEW_LINK=${SLACK_PREVIEW_LINK:-$SECOND_THUMB:-$FIRST_PREVIEW}
          if [ -n "$SLACK_PREVIEW_IMAGE_URL" ] || [ -n "$SLACK_PREVIEW_LINK" ]; then
            echo '--- sample thread reply payload (thread_ts = <TS>) ---'
            if [ -n "$SLACK_PREVIEW_IMAGE_URL" ]; then
              jq -n --arg channel "${{ secrets.SLACK_CHANNEL || 'CHANNEL_ID' }}" --arg thread_ts "<TS>" --arg text "Preview available" --arg image "$SLACK_PREVIEW_IMAGE_URL" '{channel: $channel, thread_ts: $thread_ts, text: $text, blocks: [ { type: "section", text: { type: "mrkdwn", text: $text } }, { type: "image", image_url: $image, alt_text: "preview" } ] }'
            else
              jq -n --arg channel "${{ secrets.SLACK_CHANNEL || 'CHANNEL_ID' }}" --arg thread_ts "<TS>" --arg link "$SLACK_PREVIEW_LINK" '{channel: $channel, thread_ts: $thread_ts, text: ("Preview: " + $link) }'
            fi
          fi

          # SAMPLE: Teams payload (with action + optional image) — include multiple previews as facts if available
          echo '--- sample teams payload ---'
          TEAMS_MENTION=${{ secrets.TEAMS_MENTION || '' }}
          TEAMS_COLOR=${{ secrets.TEAMS_COLOR || '0076D7' }}
          TEAMS_PREVIEW_LINK=${{ secrets.TEAMS_PREVIEW_LINK || '' }}
          TEAMS_IMAGE_URL=${{ secrets.TEAMS_IMAGE_URL || '' }}
          TEAMS_ACTION_TEXT=${{ secrets.TEAMS_ACTION_TEXT || 'Open preview' }}
          # choose preview link with fallback to run URL
          PREVIEW=${TEAMS_PREVIEW_LINK:-$RUN_URL}
          # pick up all preview_urls into a compact list for sample output
          ALL_PREVIEWS=$(jq -r '.preview_urls // [] | .[]' "$FILE" | head -n${{ secrets.PREVIEWS_MAX || '5' }} || true)
          if [ -n "$TEAMS_IMAGE_URL" ] || [ -n "$ALL_PREVIEWS" ]; then
            # prefer first preview image if TEAMS_IMAGE_URL is not set
            if [ -z "$TEAMS_IMAGE_URL" ] && [ -n "$ALL_PREVIEWS" ]; then
              TEAMS_IMAGE_URL=$(echo "$ALL_PREVIEWS" | head -n1)
            fi
            jq -n --arg mention "$TEAMS_MENTION" --arg pr "$PR" --arg mergedBy "$MERGED_BY" --arg short "$SHORT_SHA" --arg commitUrl "$COMMIT_URL" --arg runUrl "$RUN_URL" --arg time "$TIMESTAMP" --arg files "$FILES" --arg color "$TEAMS_COLOR" --arg preview "$PREVIEW" --arg image "$TEAMS_IMAGE_URL" --arg actionText "$TEAMS_ACTION_TEXT" '{"@type":"MessageCard","@context":"http://schema.org/extensions","summary":"Playwright snapshots auto-merged","themeColor":$color,"title":"Playwright snapshots auto-merged — PR #"+$pr,"sections":[{"activityTitle":($mention+" Merged by " + $mergedBy + " — " + $short),"facts":[{"name":"PR","value":"#"+$pr},{"name":"Files","value":$files},{"name":"Commit","value":$commitUrl},{"name":"Workflow run","value":$runUrl},{"name":"Time","value":$time}]},{"startGroup":true,"images":[{"image":$image,"title":"Snapshot preview"}]}],"potentialAction":[{"@type":"OpenUri","name":$actionText,"targets":[{"os":"default","uri":$preview}]}]}'
          else
            jq -n --arg mention "$TEAMS_MENTION" --arg pr "$PR" --arg mergedBy "$MERGED_BY" --arg short "$SHORT_SHA" --arg commitUrl "$COMMIT_URL" --arg runUrl "$RUN_URL" --arg time "$TIMESTAMP" --arg files "$FILES" --arg color "$TEAMS_COLOR" --arg preview "$PREVIEW" --arg actionText "$TEAMS_ACTION_TEXT" '{"@type":"MessageCard","@context":"http://schema.org/extensions","summary":"Playwright snapshots auto-merged","themeColor":$color,"title":"Playwright snapshots auto-merged — PR #"+$pr,"sections":[{"activityTitle":($mention+" Merged by " + $mergedBy + " — " + $short),"facts":[{"name":"PR","value":"#"+$pr},{"name":"Files","value":$files},{"name":"Commit","value":$commitUrl},{"name":"Workflow run","value":$runUrl},{"name":"Time","value":$time}]}],"potentialAction":[{"@type":"OpenUri","name":$actionText,"targets":[{"os":"default","uri":$preview}]}]}'
          fi

          # SAMPLE: Discord payload — include image + mention and list other preview links
          echo '--- sample discord payload ---'
          DISCORD_MENTION=${{ secrets.DISCORD_MENTION || '' }}
          DISCORD_COLOR=${{ secrets.DISCORD_COLOR || '3066993' }}
          DISCORD_TITLE_EMOJI=${{ secrets.DISCORD_TITLE_EMOJI || ':package:' }}
          DISCORD_IMAGE_URL=${{ secrets.DISCORD_IMAGE_URL || '' }}
          DISCORD_IMAGE_ALT=${{ secrets.DISCORD_IMAGE_ALT || 'Snapshot preview' }}
          ALL_PREVIEWS=$(jq -r '.preview_urls // [] | .[]' "$FILE" | head -n${{ secrets.PREVIEWS_MAX || '5' }} || true)
          if [ -z "$DISCORD_IMAGE_URL" ] && [ -n "$ALL_PREVIEWS" ]; then
            # prefer thumbnail first
            FIRST_THUMB_DISCORD=$(jq -r '.thumbnail_urls[0] // empty' "$FILE" || true)
            DISCORD_IMAGE_URL=${DISCORD_IMAGE_URL:-$FIRST_THUMB_DISCORD}
            DISCORD_IMAGE_URL=${DISCORD_IMAGE_URL:-$(echo "$ALL_PREVIEWS" | head -n1)}
          fi
          EXTRA_LINKS=$(echo "$ALL_PREVIEWS" | tail -n +2 | awk '{print "- " $0}' | paste -s -d"\n" - || true)
          if [ -n "$EXTRA_LINKS" ]; then
            echo '--- extra preview links ---'
            echo "$EXTRA_LINKS"
          fi

      - name: Post sample payloads to TEST_WEBHOOK (dry-run)
        if: ${{ secrets.TEST_NOTIFY == 'true' && secrets.TEST_WEBHOOK != '' }}
        env:
          TEST_WEBHOOK: ${{ secrets.TEST_WEBHOOK }}
          TEST_WEBHOOK_PLATFORM: ${{ secrets.TEST_WEBHOOK_PLATFORM || 'all' }}
        run: |
          echo "Posting sample payloads to $TEST_WEBHOOK";
          node tools/send-test-webhook.js $TEST_WEBHOOK_PLATFORM || true
            jq -n --arg emoji "$DISCORD_TITLE_EMOJI" --arg pr "$PR" --arg mergedBy "$MERGED_BY" --arg short "$SHORT_SHA" --arg commitUrl "$COMMIT_URL" --arg runUrl "$RUN_URL" --arg time "$TIMESTAMP" --arg files "$FILES" --arg color "$DISCORD_COLOR" --arg mention "$DISCORD_MENTION" --arg image "$DISCORD_IMAGE_URL" '{username: "Snapshot CI", content: $mention, embeds: [{title: ($emoji + " Playwright snapshots auto-merged — PR #" + $pr), description: ("Merged by " + $mergedBy + " — " + $short), color: ($color|tonumber), fields: [{name: "Files", value: $files, inline: false}, {name: "Commit", value: $commitUrl, inline: false}, {name: "Workflow run", value: $runUrl, inline: false}, {name: "Time", value: $time, inline: false}], image: {url: $image}}]}'
          else
            jq -n --arg emoji "$DISCORD_TITLE_EMOJI" --arg pr "$PR" --arg mergedBy "$MERGED_BY" --arg short "$SHORT_SHA" --arg commitUrl "$COMMIT_URL" --arg runUrl "$RUN_URL" --arg time "$TIMESTAMP" --arg files "$FILES" --arg color "$DISCORD_COLOR" --arg mention "$DISCORD_MENTION" '{username: "Snapshot CI", content: $mention, embeds: [{title: ($emoji + " Playwright snapshots auto-merged — PR #" + $pr), description: ("Merged by " + $mergedBy + " — " + $short), color: ($color|tonumber), fields: [{name: "Files", value: $files, inline: false}, {name: "Commit", value: $commitUrl, inline: false}, {name: "Workflow run", value: $runUrl, inline: false}, {name: "Time", value: $time, inline: false}]}]}'
          fi

      - name: Notify Slack webhook / API (optional)
        if: ${{ secrets.SLACK_WEBHOOK != '' || secrets.SLACK_BOT_TOKEN != '' }}
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN || '' }}
          SLACK_CHANNEL: ${{ secrets.SLACK_CHANNEL || '' }}
          SLACK_POST_IN_THREAD: ${{ secrets.SLACK_POST_IN_THREAD || 'false' }}
          SLACK_PREVIEW_IMAGE_URL: ${{ secrets.SLACK_PREVIEW_IMAGE_URL || '' }}
          SLACK_PREVIEW_LINK: ${{ secrets.SLACK_PREVIEW_LINK || '' }}
          SLACK_MENTION: ${{ secrets.SLACK_MENTION || '' }}
          SLACK_EMOJI: ${{ secrets.SLACK_EMOJI || '' }}
          SLACK_COLOR: ${{ secrets.SLACK_COLOR || '#36a64f' }}
          SLACK_TITLE_LINK: ${{ secrets.SLACK_TITLE_LINK || '' }}
        run: |
          set -e
          FILE=$(ls snapshot-merge-artifacts/*.json | head -n1 || true)
          if [ -z "$FILE" ]; then echo "No metadata file found. Skipping Slack notification." ; exit 0; fi
          PR=$(jq -r .pr "$FILE")
          SHORT_SHA=$(jq -r .short_sha "$FILE")
          MERGED_BY=$(jq -r .merged_by "$FILE")
          COMMIT_URL=$(jq -r .commit_url "$FILE")
          RUN_URL=$(jq -r .run_url "$FILE")
          TIMESTAMP=$(jq -r .timestamp "$FILE")
          FILES=$(jq -r '.files_changed | join(", ")' "$FILE")
          MENTION=${SLACK_MENTION:-}
          # if the metadata contains a generated preview URL, prefer that over secrets
          META_PREVIEW=$(jq -r '.preview_urls[0] // empty' snapshot-merge-artifacts/*.json 2>/dev/null | head -n1 || true)
          if [ -n "$META_PREVIEW" ]; then
            case "$META_PREVIEW" in
              *.png|*.jpg|*.jpeg|*.webp) SLACK_PREVIEW_IMAGE_URL="$META_PREVIEW" ;;
              *) SLACK_PREVIEW_LINK="$META_PREVIEW" ;;
            esac
          fi
          EMOJI=${SLACK_EMOJI:-}
          # build a friendly text header (mention + emoji optional)
          HEADER="${MENTION} ${EMOJI} Playwright snapshots auto-merged (PR #${PR})"
          TITLE_LINK=${SLACK_TITLE_LINK:-}
          # Build a block-kit + attachment payload for Slack so the message is structured and readable.
          PAYLOAD=$(jq -n --arg header "$HEADER" --arg pr "$PR" --arg prLink "${TITLE_LINK:-}" --arg shortSha "$SHORT_SHA" --arg mergedBy "$MERGED_BY" --arg commitUrl "$COMMIT_URL" --arg runUrl "$RUN_URL" --arg timestamp "$TIMESTAMP" --arg files "$FILES" --arg color "${SLACK_COLOR}" '{text: $header, blocks: [ { type: "section", text: { type: "mrkdwn", text: ("*Playwright snapshots auto-merged*\n*PR:* " + ( $prLink | select(.!= "") ) + " | `#" + $pr + "` | *Merged by:* " + $mergedBy) } }, { type: "section", fields: [ { type: "mrkdwn", text: ("*Commit*\n<" + $commitUrl + ">") }, { type: "mrkdwn", text: ("*Workflow run*\n<" + $runUrl + ">") } ] }, { type: "context", elements: [ { type: "mrkdwn", text: ("*Files changed:* " + ($files | select(.!= ""))) } ] } ], attachments: [{ color: $color }] }')

          # If configured, try to post via Slack API and then reply in-thread with preview image/link.
          if [ "$SLACK_POST_IN_THREAD" = 'true' ] && [ -n "$SLACK_BOT_TOKEN" ] && [ -n "$SLACK_CHANNEL" ]; then
            echo "Posting initial message to Slack channel $SLACK_CHANNEL via chat.postMessage"
            RES=$(curl -s -X POST -H "Authorization: Bearer $SLACK_BOT_TOKEN" -H 'Content-type: application/json' -d "{\"channel\": \"$SLACK_CHANNEL\", \"blocks\": $(echo "$PAYLOAD" | jq -c '.blocks'), \"text\": $(echo "$PAYLOAD" | jq -c '.text')}" https://slack.com/api/chat.postMessage)
            OK=$(echo "$RES" | jq -r .ok || echo false)
            if [ "$OK" = "true" ]; then
              TS=$(echo "$RES" | jq -r .ts)
              echo "Posted main message ts=$TS"
              # if we have a preview image or link, post as a thread reply
              if [ -n "$SLACK_PREVIEW_IMAGE_URL" ] || [ -n "$SLACK_PREVIEW_LINK" ]; then
                THREAD_TEXT="Preview: ${SLACK_PREVIEW_LINK:-}${SLACK_PREVIEW_IMAGE_URL:+ (image) }"
                THREAD_BLOCKS='[ { "type":"section", "text": { "type": "mrkdwn", "text": "*Preview\n*'"$THREAD_TEXT"'" } }'
                if [ -n "$SLACK_PREVIEW_IMAGE_URL" ]; then
                  THREAD_BLOCKS=\"$THREAD_BLOCKS, { \"type\": \"image\", \"image_url\": \"$SLACK_PREVIEW_IMAGE_URL\", \"alt_text\": \"preview\" } ]\"
                else
                  THREAD_BLOCKS=\"$THREAD_BLOCKS ]\"
                fi
                echo "Posting in-thread preview"
                THREAD_RES=$(curl -s -X POST -H "Authorization: Bearer $SLACK_BOT_TOKEN" -H 'Content-type: application/json' -d "{\"channel\": \"$SLACK_CHANNEL\", \"thread_ts\": \"$TS\", \"text\": \"$THREAD_TEXT\", \"blocks\": $THREAD_BLOCKS }" https://slack.com/api/chat.postMessage)
                echo "Thread post response:" $THREAD_RES
              fi
            else
              echo "Slack API post failed, falling back to webhook. Response: $RES"
              curl -s -X POST -H 'Content-type: application/json' --data "$PAYLOAD" "$SLACK_WEBHOOK" || echo "Slack webhook fallback failed"
            fi
          else
            # no bot token or not configured to post in thread — use incoming webhook (if present)
            if [ -n "$SLACK_WEBHOOK" ]; then
              curl -s -X POST -H 'Content-type: application/json' --data "$PAYLOAD" "$SLACK_WEBHOOK" || echo "Slack notification failed"
            else
              echo "No Slack webhook configured; skipping Slack notification"
            fi
          fi
          curl -s -X POST -H 'Content-type: application/json' --data "$PAYLOAD" "$SLACK_WEBHOOK" || echo "Slack notification failed"

      - name: Notify Microsoft Teams (optional)
        if: ${{ secrets.TEAMS_WEBHOOK != '' }}
        env:
          TEAMS_WEBHOOK: ${{ secrets.TEAMS_WEBHOOK }}
          TEAMS_MENTION: ${{ secrets.TEAMS_MENTION || '' }}
          TEAMS_COLOR: ${{ secrets.TEAMS_COLOR || '0076D7' }}
          TEAMS_PREVIEW_LINK: ${{ secrets.TEAMS_PREVIEW_LINK || '' }}
          TEAMS_IMAGE_URL: ${{ secrets.TEAMS_IMAGE_URL || '' }}
          TEAMS_ACTION_TEXT: ${{ secrets.TEAMS_ACTION_TEXT || 'Open preview' }}
        run: |
          set -e
          FILE=$(ls snapshot-merge-artifacts/*.json | head -n1 || true)
          if [ -z "$FILE" ]; then echo "No metadata file found. Skipping Teams notification." ; exit 0; fi
          PR=$(jq -r .pr "$FILE")
          SHORT_SHA=$(jq -r .short_sha "$FILE")
          MERGED_BY=$(jq -r .merged_by "$FILE")
          COMMIT_URL=$(jq -r .commit_url "$FILE")
          RUN_URL=$(jq -r .run_url "$FILE")
          TIMESTAMP=$(jq -r .timestamp "$FILE")
          FILES=$(jq -r '.files_changed | join(", ")' "$FILE")
          # Build a richer MessageCard for Teams with a summary, themeColor and facts list
          MENTION=${TEAMS_MENTION:-}
          META_PREVIEW=$(jq -r '.preview_urls[0] // empty' snapshot-merge-artifacts/*.json 2>/dev/null | head -n1 || true)
          if [ -n "$META_PREVIEW" ]; then
            case "$META_PREVIEW" in
              *.png|*.jpg|*.jpeg|*.webp) TEAMS_IMAGE_URL="$META_PREVIEW" ;;
              *) TEAMS_PREVIEW_LINK="$META_PREVIEW" ;;
            esac
          fi
          MENTION=${TEAMS_MENTION:-}
          # Build MessageCard payload for Teams — optionally include an image and an action button
          read -r -d '' BODY <<- MSG
          {
            "@type": "MessageCard",
            "@context": "http://schema.org/extensions",
            "summary": "Playwright snapshots auto-merged",
            "themeColor": "${TEAMS_COLOR}",
            "title": "Playwright snapshots auto-merged — PR #${PR}",
            "sections": [
              {
                "activityTitle": "${MENTION} Merged by ${MERGED_BY} — ${SHORT_SHA}",
                "facts": [
                  {"name": "PR", "value": "#${PR}"},
                  {"name": "Files", "value": "${FILES}"},
                  {"name": "Commit", "value": "${COMMIT_URL}"},
                  {"name": "Workflow run", "value": "${RUN_URL}"},
                  {"name": "Time", "value": "${TIMESTAMP}"}
                ]
              }${TEAMS_IMAGE_URL:+,
              {
                "startGroup": true,
                "images": [{"image": "${TEAMS_IMAGE_URL}", "title": "Snapshot preview"}]
              }
              }
            ],
            "potentialAction": [
              {
                "@type": "OpenUri",
                "name": "${TEAMS_ACTION_TEXT}",
                "targets": [ { "os": "default", "uri": "${TEAMS_PREVIEW_LINK:-${RUN_URL}}" } ]
              }
            ]
          }
          MSG

          curl -sS -X POST -H 'Content-Type: application/json' --data "$BODY" "$TEAMS_WEBHOOK" || echo "Teams notification failed"

      - name: Notify Discord webhook (optional)
        if: ${{ secrets.DISCORD_WEBHOOK != '' }}
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          DISCORD_MENTION: ${{ secrets.DISCORD_MENTION || '' }}
          DISCORD_COLOR: ${{ secrets.DISCORD_COLOR || '3066993' }}
          DISCORD_TITLE_EMOJI: ${{ secrets.DISCORD_TITLE_EMOJI || ':package:' }}
          DISCORD_IMAGE_URL: ${{ secrets.DISCORD_IMAGE_URL || '' }}
          DISCORD_IMAGE_ALT: ${{ secrets.DISCORD_IMAGE_ALT || 'Snapshot preview' }}
        run: |
          set -e
          FILE=$(ls snapshot-merge-artifacts/*.json | head -n1 || true)
          if [ -z "$FILE" ]; then echo "No metadata file found. Skipping Discord notification." ; exit 0; fi
          PR=$(jq -r .pr "$FILE")
          SHORT_SHA=$(jq -r .short_sha "$FILE")
          MERGED_BY=$(jq -r .merged_by "$FILE")
          COMMIT_URL=$(jq -r .commit_url "$FILE")
          RUN_URL=$(jq -r .run_url "$FILE")
          TIMESTAMP=$(jq -r .timestamp "$FILE")
          FILES=$(jq -r '.files_changed | join(", ")' "$FILE")
          # Prefer preview URL from metadata when available
          META_PREVIEW=$(jq -r '.preview_urls[0] // empty' snapshot-merge-artifacts/*.json 2>/dev/null | head -n1 || true)
          if [ -n "$META_PREVIEW" ]; then
            case "$META_PREVIEW" in
              *.png|*.jpg|*.jpeg|*.webp) DISCORD_IMAGE_URL="$META_PREVIEW" ;;
              *) DISCORD_PREVIEW_LINK="$META_PREVIEW" ;;
            esac
          fi

          # Discord webhook payload (embed) — include color, emoji, fields and optional image
          read -r -d '' PAYLOAD <<- JSON
          {
            "username": "Snapshot CI",
            "embeds": [
              {
                "title": "${DISCORD_TITLE_EMOJI} Playwright snapshots auto-merged — PR #${PR}",
                "description": "Merged by ${MERGED_BY} — ${SHORT_SHA}",
                "color": ${DISCORD_COLOR:-3066993},
                "fields": [
                  {"name": "PR", "value": "#${PR}", "inline": true},
                  {"name": "Files", "value": "${FILES}", "inline": false},
                  {"name": "Commit", "value": "${COMMIT_URL}", "inline": false},
                  {"name": "Workflow run", "value": "${RUN_URL}", "inline": false},
                  {"name": "Time", "value": "${TIMESTAMP}", "inline": false}
                ]
                ${DISCORD_IMAGE_URL:+, "image": { "url": "${DISCORD_IMAGE_URL}", "alt": "${DISCORD_IMAGE_ALT}" }}
              }
            ]
          }
          JSON

          CONTENT=${DISCORD_MENTION:-}
          # include mention separately so it pings reliably; Discord supports sending a top-level content string
          if [ -n "$CONTENT" ]; then
            FINAL_PAYLOAD=$(jq -n --arg content "$CONTENT" --argjson embeds "$(echo "$PAYLOAD" | jq -c '.embeds')" '{content: $content, embeds: $embeds}')
            curl -sS -X POST -H 'Content-Type: application/json' --data "$FINAL_PAYLOAD" "$DISCORD_WEBHOOK" || echo "Discord notification failed"
          else
            curl -sS -X POST -H 'Content-Type: application/json' --data "$PAYLOAD" "$DISCORD_WEBHOOK" || echo "Discord notification failed"
          fi

